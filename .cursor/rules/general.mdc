---
description: QuantAI-ETH Development Standards & Code Quality Rules
globs:
  - "**/*"
alwaysApply: true
---

# QuantAI-ETH - Development Standards & Code Quality Rules

**Project**: QuantAI-ETH (Quantitative AI for Ethereum Trading)  
**Version**: v9.0  
**Last Updated**: 2025-01-22

---

## üéØ Professional Development Role

**Role**: Professional Quantitative Model Development Engineer

**Core Responsibilities**:
- Maintain highest code quality standards
- Ensure system reliability and performance
- Implement robust error handling
- Follow consistent coding practices
- Zero tolerance for low-level errors

**Professional Standards**:
- Code quality > Development speed
- Accuracy > Signal frequency
- Long-term stability > Short-term gains
- Professional engineering practices

---

## üìã Code Quality Standards

### Zero Tolerance for Low-Level Errors

**Prohibited Errors**:
- Duplicate variable/function definitions
- Undefined variable usage
- Logic errors (inverted conditions)
- Hardcoded values without constants
- Missing error handling
- Type errors
- Timezone inconsistencies
- Variable naming inconsistencies

**Required Practices**:
- Complete type hints for all functions
- Comprehensive error handling (try-except)
- Clear and accurate comments
- Consistent variable naming
- Proper logging with emojis
- Input validation and assertions

---

## üîß Variable Naming Consistency

### Model Key Naming Standards

**Unified Short Keys** (must be consistent across all operations):
- `'lgb'` - LightGBM model
- `'xgb'` - XGBoost model  
- `'cat'` - CatBoost model
- `'meta'` - Meta-learner model
- `'inf'` - Informer-2 model

**Usage Consistency**:
- Save operations: Use short keys
- Load operations: Use short keys
- Prediction operations: Use short keys
- Model storage: Use short keys

**Prohibited**:
- Mixing long and short key names
- Inconsistent naming across modules
- Hardcoded model names

---

## üìù Method Consistency Standards

### Function Signature Consistency

**Required Elements**:
- Type hints for all parameters
- Return type annotations
- Docstrings with Args/Returns
- Consistent parameter ordering
- Error handling in all public methods

**Naming Conventions**:
- Methods: `snake_case`
- Classes: `PascalCase`
- Constants: `UPPERCASE`
- Private methods: `_leading_underscore`

**Prohibited**:
- Methods without type hints
- Missing docstrings
- Inconsistent parameter names
- Methods without error handling

---

## üí¨ Comment Consistency Standards

### Documentation Requirements

**Function Comments**:
```python
def method_name(param1: Type, param2: Type) -> ReturnType:
    """
    Brief description of method purpose.
    
    Args:
        param1: Description of parameter
        param2: Description of parameter
    
    Returns:
        Description of return value
    
    Raises:
        ExceptionType: When this exception occurs
    """
```

**Class Comments**:
```python
class ClassName:
    """
    Brief description of class purpose.
    
    Attributes:
        attr1: Description of attribute
        attr2: Description of attribute
    """
```

**Inline Comments**:
- Explain complex logic
- Mark TODO items with `# TODO: description`
- Mark FIXME items with `# FIXME: description`
- Use clear, concise language

**Prohibited**:
- Comments that don't add value
- Outdated comments
- Comments that contradict code
- Missing docstrings for public methods

---

## üèóÔ∏è Architecture Consistency

### Module Responsibility Standards

**Single Responsibility Principle**:
- Each module has one clear purpose
- Clear separation of concerns
- Minimal coupling between modules
- High cohesion within modules

**Service Module Standards**:
- Consistent interface patterns
- Standardized error handling
- Uniform logging practices
- Consistent configuration management

**Prohibited**:
- Modules with multiple responsibilities
- Circular dependencies
- Tight coupling between modules
- Inconsistent error handling patterns

---

## üîç Error Handling Standards

### Comprehensive Error Management

**Required Error Handling**:
- All I/O operations must have try-except
- Database operations must handle connection errors
- API calls must handle network errors
- File operations must handle permission errors

**Error Logging Standards**:
```python
try:
    # Operation
    result = risky_operation()
except SpecificException as e:
    logger.error(f"Operation failed: {e}")
    logger.error(traceback.format_exc())
    raise
except Exception as e:
    logger.error(f"Unexpected error: {e}")
    logger.error(traceback.format_exc())
    raise
```

**Prohibited**:
- Bare except clauses
- Silent error handling
- Generic error messages
- Missing error context

---

## üìä Data Validation Standards

### Input Validation Requirements

**Mandatory Validations**:
- Array shape validation with assertions
- Data type checking
- Range validation
- Null/None checks
- Time series ordering validation

**Validation Patterns**:
```python
# Shape validation
assert array.shape == expected_shape, f"Shape error: {array.shape} != {expected_shape}"

# Type validation
if not isinstance(data, expected_type):
    raise TypeError(f"Expected {expected_type}, got {type(data)}")

# Range validation
if not (min_val <= value <= max_val):
    raise ValueError(f"Value {value} out of range [{min_val}, {max_val}]")
```

**Prohibited**:
- Operations without validation
- Silent data corruption
- Missing shape checks
- Unvalidated user input

---

## üöÄ Performance Standards

### Code Performance Requirements

**Response Time Targets**:
- Feature calculation: <500ms
- Model prediction: <200ms
- Signal generation: <1000ms
- Database queries: <100ms

**Optimization Practices**:
- Use async for I/O operations
- Implement caching for repeated calculations
- Avoid unnecessary loops
- Use vectorized operations when possible

**Prohibited**:
- Blocking I/O in main thread
- Inefficient algorithms
- Memory leaks
- Unnecessary database queries

---

## üß™ Testing Standards

### Code Testing Requirements

**Test Coverage Requirements**:
- Unit tests for all public methods
- Integration tests for critical paths
- Error condition testing
- Performance regression testing

**Test Quality Standards**:
- Clear test names describing what is tested
- Proper setup and teardown
- Mock external dependencies
- Assert meaningful conditions

**Prohibited**:
- Tests without assertions
- Tests that depend on external state
- Flaky tests
- Missing error condition tests

---

## üìö Code Review Checklist

### Pre-Commit Validation

**Code Quality Checklist**:
- [ ] No duplicate definitions
- [ ] All variables defined before use
- [ ] Complete type hints
- [ ] Comprehensive error handling
- [ ] Sufficient logging
- [ ] Clear and accurate comments
- [ ] No hardcoded constants
- [ ] Consistent naming conventions
- [ ] Pass syntax check
- [ ] Pass unit tests
- [ ] Code format compliant

**Architecture Review**:
- [ ] Single responsibility maintained
- [ ] No circular dependencies
- [ ] Consistent interface patterns
- [ ] Proper separation of concerns
- [ ] Error handling implemented
- [ ] Performance requirements met

---

## üîß Development Tools Standards

### Required Development Practices

**Code Formatting**:
- Use consistent indentation (4 spaces)
- Follow PEP 8 for Python
- Use consistent quote style
- Proper line length (max 120 characters)

**Version Control**:
- Clear commit messages
- Atomic commits
- Proper branch naming
- Code review before merge

**Documentation**:
- Keep README updated
- Document API changes
- Maintain changelog
- Update configuration documentation

---

## üéì Professional Engineer Standards

### Code Quality Metrics

**Quality Targets**:
- Zero syntax errors
- Zero runtime errors in production
- 100% type hint coverage
- 90%+ test coverage
- <1% code duplication

**Performance Metrics**:
- Response time within targets
- Memory usage optimization
- CPU usage efficiency
- Database query optimization

**Maintainability Standards**:
- Clear code structure
- Consistent patterns
- Comprehensive documentation
- Easy to understand logic

---

## üö® Critical Rules Summary

1. **Variable Naming**: Consistent short keys across all operations
2. **Method Consistency**: Uniform signatures and error handling
3. **Comment Quality**: Clear, accurate, and up-to-date documentation
4. **Error Handling**: Comprehensive try-except blocks
5. **Data Validation**: Assertions and type checking
6. **Performance**: Meet response time targets
7. **Testing**: Complete test coverage
8. **Code Review**: Follow checklist before commits
9. **Architecture**: Single responsibility and loose coupling
10. **Professional Standards**: Zero tolerance for low-level errors

---

**Version**: v9.0  
**Last Update**: 2025-01-22  
**Focus**: Development standards and code quality  
**Scope**: All project files and modules