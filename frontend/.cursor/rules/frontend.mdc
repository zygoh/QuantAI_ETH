---
description: å‰ç«¯å¼€å‘è§„åˆ™ - React/TypeScript
globs:
  - "frontend/**/*.ts"
  - "frontend/**/*.tsx"
alwaysApply: true
---

# å‰ç«¯å¼€å‘è§„åˆ™

## âš›ï¸ React/TypeScriptè§„èŒƒ

### ç»„ä»¶è®¾è®¡åŸåˆ™

```typescript
// âœ… æ¨èï¼šå‡½æ•°ç»„ä»¶ + TypeScript
interface DashboardProps {
  symbol: string;
  onRefresh?: () => void;
}

const Dashboard: React.FC<DashboardProps> = ({ symbol, onRefresh }) => {
  const [loading, setLoading] = useState(false);
  
  return (
    <div className="dashboard">
      {/* UI */}
    </div>
  );
};

// âŒ é¿å…ï¼šç±»ç»„ä»¶ï¼ˆé™¤éå¿…è¦ï¼‰
class Dashboard extends React.Component<DashboardProps> {
  // ä¸æ¨èæ–°ä»£ç ä½¿ç”¨
}
```

### è‡ªå®šä¹‰Hookå¤ç”¨é€»è¾‘

```typescript
// âœ… æ­£ç¡®ï¼šæŠ½å–å¤ç”¨é€»è¾‘åˆ°è‡ªå®šä¹‰Hook
const useSignalData = (symbol: string) => {
  const [signals, setSignals] = useState<TradingSignal[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  useEffect(() => {
    fetchSignals(symbol)
      .then(setSignals)
      .catch(err => setError(err.message))
      .finally(() => setLoading(false));
  }, [symbol]);
  
  return { signals, loading, error };
};

// ä½¿ç”¨
const Dashboard: React.FC = () => {
  const { signals, loading, error } = useSignalData('ETHUSDT');
  
  if (loading) return <Spinner />;
  if (error) return <Error message={error} />;
  
  return <SignalList signals={signals} />;
};

// âŒ é”™è¯¯ï¼šåœ¨ç»„ä»¶ä¸­é‡å¤ç›¸åŒé€»è¾‘
const Dashboard: React.FC = () => {
  const [signals, setSignals] = useState<TradingSignal[]>([]);
  // ... é‡å¤çš„è·å–é€»è¾‘
};

const Signals: React.FC = () => {
  const [signals, setSignals] = useState<TradingSignal[]>([]);
  // ... ç›¸åŒçš„è·å–é€»è¾‘  // âŒ åº”è¯¥æŠ½å–ä¸ºHook
};
```

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
frontend/src/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Dashboard/        # ä»ªè¡¨ç›˜ç›¸å…³ç»„ä»¶
â”‚   â”œâ”€â”€ Layout/           # å¸ƒå±€ç»„ä»¶
â”‚   â””â”€â”€ Pages/            # é¡µé¢ç»„ä»¶
â”œâ”€â”€ contexts/
â”‚   â”œâ”€â”€ DataContext.tsx   # æ•°æ®ä¸Šä¸‹æ–‡
â”‚   â””â”€â”€ WebSocketContext.tsx  # WebSocketä¸Šä¸‹æ–‡
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ api.ts            # APIè°ƒç”¨å°è£…
â”‚   â””â”€â”€ websocket.ts      # WebSocketç®¡ç†
â”œâ”€â”€ utils/                # å…¬å…±å·¥å…·å‡½æ•° â­
â”‚   â”œâ”€â”€ formatters.ts     # æ ¼å¼åŒ–å·¥å…·
â”‚   â”œâ”€â”€ validators.ts     # éªŒè¯å·¥å…·
â”‚   â””â”€â”€ helpers.ts        # é€šç”¨è¾…åŠ©å‡½æ•°
â”œâ”€â”€ types/                # TypeScriptç±»å‹å®šä¹‰
â”‚   â””â”€â”€ index.ts
â”œâ”€â”€ hooks/                # è‡ªå®šä¹‰Hooks
â”‚   â”œâ”€â”€ useSignalData.ts
â”‚   â””â”€â”€ useWebSocket.ts
â””â”€â”€ App.tsx
```

---

## ğŸ¯ ä»£ç è´¨é‡è§„èŒƒ

### ç¦æ­¢å†—ä½™

```typescript
// âŒ é”™è¯¯ï¼šé‡å¤çš„æ ¼å¼åŒ–å‡½æ•°
// æ–‡ä»¶: components/Dashboard/AccountSummary.tsx
const formatPrice = (price: number) => `$${price.toFixed(2)}`;

// æ–‡ä»¶: components/Dashboard/PositionsSummary.tsx
const formatPrice = (price: number) => `$${price.toFixed(2)}`;  // âŒ é‡å¤

// âœ… æ­£ç¡®ï¼šæŠ½å–åˆ°utils
// æ–‡ä»¶: utils/formatters.ts
export const formatPrice = (price: number): string => {
  return `$${price.toFixed(2)}`;
};

// ä½¿ç”¨
import { formatPrice } from '@/utils/formatters';
```

### å•ä¸€èŒè´£

```typescript
// âœ… æ­£ç¡®ï¼šèŒè´£åˆ†ç¦»
// æ•°æ®è·å–é€»è¾‘
const fetchSignals = async (symbol: string): Promise<TradingSignal[]> => {
  const response = await fetch(`/api/signals/${symbol}`);
  return response.json();
};

// UIå±•ç¤ºé€»è¾‘
const SignalList: React.FC<{ signals: TradingSignal[] }> = ({ signals }) => {
  return (
    <ul>
      {signals.map(signal => (
        <li key={signal.id}>{signal.type}</li>
      ))}
    </ul>
  );
};

// âŒ é”™è¯¯ï¼šæ··åˆèŒè´£
const SignalList: React.FC = () => {
  const [signals, setSignals] = useState<TradingSignal[]>([]);
  
  // æ•°æ®è·å– + UIæ¸²æŸ“æ··åœ¨ä¸€èµ·  // âŒ
  useEffect(() => {
    fetch('/api/signals')
      .then(res => res.json())
      .then(setSignals);
  }, []);
  
  return <ul>{/* UI */}</ul>;
};
```

---

## ğŸ”Œ APIè°ƒç”¨è§„èŒƒ

### ç»Ÿä¸€APIå°è£…

```typescript
// âœ… æ­£ç¡®ï¼šç»Ÿä¸€çš„APIæœåŠ¡
// æ–‡ä»¶: services/api.ts
import axios, { AxiosInstance } from 'axios';

class ApiService {
  private client: AxiosInstance;
  
  constructor() {
    this.client = axios.create({
      baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:8000',
      timeout: 10000,
    });
    
    // æ‹¦æˆªå™¨
    this.client.interceptors.response.use(
      response => response.data,
      error => {
        console.error('API Error:', error);
        throw error;
      }
    );
  }
  
  // è·å–ä¿¡å·
  async getSignals(symbol: string): Promise<TradingSignal[]> {
    return this.client.get(`/api/signals/${symbol}`);
  }
  
  // è·å–æŒä»“
  async getPositions(): Promise<Position[]> {
    return this.client.get('/api/positions');
  }
  
  // è·å–è´¦æˆ·ä¿¡æ¯
  async getAccount(): Promise<AccountInfo> {
    return this.client.get('/api/account');
  }
}

export const apiService = new ApiService();

// âŒ é”™è¯¯ï¼šåœ¨ç»„ä»¶ä¸­ç›´æ¥è°ƒç”¨
const Dashboard: React.FC = () => {
  useEffect(() => {
    fetch('http://localhost:8000/api/signals')  // âŒ ç¡¬ç¼–ç URL
      .then(res => res.json())
      .then(setSignals);
  }, []);
};
```

### é”™è¯¯å¤„ç†

```typescript
// âœ… æ­£ç¡®ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†
const useSignalData = (symbol: string) => {
  const [signals, setSignals] = useState<TradingSignal[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);
  
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        setError(null);
        const data = await apiService.getSignals(symbol);
        setSignals(data);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error'));
        console.error('Failed to fetch signals:', err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchData();
  }, [symbol]);
  
  return { signals, loading, error };
};

// âŒ é”™è¯¯ï¼šæ²¡æœ‰é”™è¯¯å¤„ç†
const useSignalData = (symbol: string) => {
  const [signals, setSignals] = useState<TradingSignal[]>([]);
  
  useEffect(() => {
    apiService.getSignals(symbol).then(setSignals);  // âŒ æ²¡æœ‰catch
  }, [symbol]);
  
  return { signals };
};
```

---

## ğŸŒ WebSocketè§„èŒƒ

### WebSocketç®¡ç†

```typescript
// âœ… æ­£ç¡®ï¼šç»Ÿä¸€çš„WebSocketç®¡ç†
// æ–‡ä»¶: services/websocket.ts
class WebSocketService {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  
  connect(url: string, onMessage: (data: any) => void) {
    this.ws = new WebSocket(url);
    
    this.ws.onopen = () => {
      console.log('âœ… WebSocketè¿æ¥æˆåŠŸ');
      this.reconnectAttempts = 0;
    };
    
    this.ws.onmessage = (event) => {
      const data = JSON.parse(event.data);
      onMessage(data);
    };
    
    this.ws.onerror = (error) => {
      console.error('âŒ WebSocketé”™è¯¯:', error);
    };
    
    this.ws.onclose = () => {
      console.log('WebSocketè¿æ¥å…³é—­');
      this.reconnect(url, onMessage);
    };
  }
  
  private reconnect(url: string, onMessage: (data: any) => void) {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      console.log(`å°è¯•é‡è¿ (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
      setTimeout(() => this.connect(url, onMessage), 3000);
    }
  }
  
  disconnect() {
    if (this.ws) {
      this.ws.close();
      this.ws = null;
    }
  }
}

export const wsService = new WebSocketService();
```

### Contexté›†æˆ

```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨Contextç®¡ç†WebSocketçŠ¶æ€
// æ–‡ä»¶: contexts/WebSocketContext.tsx
interface WebSocketContextType {
  isConnected: boolean;
  latestSignal: TradingSignal | null;
  latestPrice: number | null;
}

export const WebSocketContext = createContext<WebSocketContextType | null>(null);

export const WebSocketProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [isConnected, setIsConnected] = useState(false);
  const [latestSignal, setLatestSignal] = useState<TradingSignal | null>(null);
  const [latestPrice, setLatestPrice] = useState<number | null>(null);
  
  useEffect(() => {
    const wsUrl = 'ws://localhost:8000/ws';
    
    wsService.connect(wsUrl, (data) => {
      if (data.type === 'signal') {
        setLatestSignal(data.signal);
      } else if (data.type === 'price') {
        setLatestPrice(data.price);
      }
    });
    
    setIsConnected(true);
    
    return () => {
      wsService.disconnect();
      setIsConnected(false);
    };
  }, []);
  
  return (
    <WebSocketContext.Provider value={{ isConnected, latestSignal, latestPrice }}>
      {children}
    </WebSocketContext.Provider>
  );
};

// è‡ªå®šä¹‰Hook
export const useWebSocket = () => {
  const context = useContext(WebSocketContext);
  if (!context) {
    throw new Error('useWebSocket must be used within WebSocketProvider');
  }
  return context;
};
```

---

## ğŸ¨ UIç»„ä»¶è§„èŒƒ

### ç»„ä»¶æ‹†åˆ†

```typescript
// âœ… æ­£ç¡®ï¼šå°è€Œä¸“æ³¨çš„ç»„ä»¶
// æ–‡ä»¶: components/Dashboard/SignalCard.tsx
interface SignalCardProps {
  signal: TradingSignal;
  isWarmup?: boolean;  // ğŸ†• æ˜¯å¦ä¸ºé¢„çƒ­ä¿¡å·
}

const SignalCard: React.FC<SignalCardProps> = ({ signal, isWarmup }) => {
  const signalColor = {
    'LONG': 'text-green-500',
    'SHORT': 'text-red-500',
    'HOLD': 'text-gray-500'
  }[signal.type];
  
  return (
    <div className="signal-card">
      {isWarmup && <span className="text-yellow-500">âš ï¸ é¢„çƒ­</span>}
      <span className={signalColor}>{signal.type}</span>
      <span>ç½®ä¿¡åº¦: {(signal.confidence * 100).toFixed(1)}%</span>
      <span>{formatTimestamp(signal.timestamp)}</span>
    </div>
  );
};

// âœ… ç»„åˆä½¿ç”¨
const SignalList: React.FC<{ signals: TradingSignal[] }> = ({ signals }) => {
  return (
    <div className="signal-list">
      {signals.map((signal, index) => (
        <SignalCard 
          key={signal.id} 
          signal={signal} 
          isWarmup={index < 5}  // å‰5ä¸ªæ ‡è®°ä¸ºé¢„çƒ­
        />
      ))}
    </div>
  );
};

// âŒ é”™è¯¯ï¼šå·¨å¤§çš„å•ä½“ç»„ä»¶
const Dashboard: React.FC = () => {
  return (
    <div>
      {/* 500è¡Œä»£ç æ··åœ¨ä¸€ä¸ªç»„ä»¶é‡Œ */}  // âŒ
    </div>
  );
};
```

### æ ·å¼ç®¡ç†

```typescript
// âœ… æ¨èï¼šä½¿ç”¨Tailwind CSSæˆ–CSS Modules
// Tailwind CSS
const Button: React.FC<ButtonProps> = ({ children, variant = 'primary' }) => {
  const baseStyles = 'px-4 py-2 rounded font-medium transition';
  const variantStyles = {
    primary: 'bg-blue-500 text-white hover:bg-blue-600',
    secondary: 'bg-gray-500 text-white hover:bg-gray-600',
    warning: 'bg-yellow-500 text-white hover:bg-yellow-600'  // ğŸ†• é¢„çƒ­ä¿¡å·
  };
  
  return (
    <button className={`${baseStyles} ${variantStyles[variant]}`}>
      {children}
    </button>
  );
};

// CSS Modules
import styles from './Button.module.css';

const Button: React.FC<ButtonProps> = ({ children }) => {
  return <button className={styles.button}>{children}</button>;
};
```

---

## ğŸ”§ å·¥å…·å‡½æ•°è§„èŒƒ

```typescript
// âœ… æ–‡ä»¶: utils/formatters.ts
export const formatPrice = (price: number): string => {
  return `$${price.toFixed(2)}`;
};

export const formatPercentage = (value: number): string => {
  return `${(value * 100).toFixed(2)}%`;
};

export const formatTimestamp = (timestamp: string): string => {
  return new Date(timestamp).toLocaleString('zh-CN', {
    timeZone: 'Asia/Shanghai'
  });
};

// ğŸ†• æ ¼å¼åŒ–ä¿¡å·çŠ¶æ€
export const formatSignalStatus = (index: number, warmupCount: number = 5): string => {
  if (index < warmupCount) {
    return `é¢„çƒ­ ${index + 1}/${warmupCount}`;
  }
  return `æ­£å¼ ${index + 1}`;
};

// âœ… æ–‡ä»¶: utils/validators.ts
export const isValidSymbol = (symbol: string): boolean => {
  return /^[A-Z]+USDT$/.test(symbol);
};

export const isValidTimeframe = (timeframe: string): boolean => {
  return ['15m', '2h', '4h'].includes(timeframe);
};

// âœ… ä½¿ç”¨
import { formatPrice, formatPercentage, formatSignalStatus } from '@/utils/formatters';
import { isValidSymbol } from '@/utils/validators';
```

---

## ğŸš« å‰ç«¯ç¦æ­¢äº‹é¡¹

```typescript
// âŒ ç¦æ­¢ï¼šåœ¨ç»„ä»¶ä¸­ç¡¬ç¼–ç API URL
fetch('http://localhost:8000/api/signals')  // âŒ

// âœ… åº”è¯¥ï¼šä½¿ç”¨ç¯å¢ƒå˜é‡å’ŒAPIæœåŠ¡
apiService.getSignals('ETHUSDT')

// âŒ ç¦æ­¢ï¼šç›´æ¥ä¿®æ”¹state
const [data, setData] = useState([]);
data.push(newItem);  // âŒ ç›´æ¥ä¿®æ”¹

// âœ… åº”è¯¥ï¼šä½¿ç”¨ä¸å¯å˜æ›´æ–°
setData([...data, newItem]);

// âŒ ç¦æ­¢ï¼šåœ¨ç»„ä»¶ä¸­é‡å¤ç›¸åŒé€»è¾‘
// å¤šä¸ªç»„ä»¶ä¸­éƒ½æœ‰ç›¸åŒçš„æ•°æ®è·å–é€»è¾‘  // âŒ

// âœ… åº”è¯¥ï¼šæŠ½å–ä¸ºè‡ªå®šä¹‰Hook
const { data, loading } = useSignalData('ETHUSDT');

// âŒ ç¦æ­¢ï¼šç¼ºå°‘é”™è¯¯å¤„ç†
useEffect(() => {
  fetchData().then(setData);  // âŒ æ²¡æœ‰catch
}, []);

// âœ… åº”è¯¥ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†
useEffect(() => {
  fetchData()
    .then(setData)
    .catch(err => {
      setError(err);
      console.error(err);
    });
}, []);

// âŒ ç¦æ­¢ï¼šuseEffectä¾èµ–é¡¹é—æ¼
useEffect(() => {
  fetchData(symbol);  // ä½¿ç”¨äº†symbol
}, []);  // âŒ ä½†æ²¡æœ‰åŠ åˆ°ä¾èµ–æ•°ç»„

// âœ… åº”è¯¥ï¼šå®Œæ•´çš„ä¾èµ–æ•°ç»„
useEffect(() => {
  fetchData(symbol);
}, [symbol]);  // âœ…
```

---

## â™¿ å¯è®¿é—®æ€§è§„èŒƒ

```typescript
// âœ… æ­£ç¡®ï¼šæ·»åŠ ariaæ ‡ç­¾å’Œè¯­ä¹‰åŒ–HTML
const Button: React.FC<ButtonProps> = ({ children, onClick, disabled }) => {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      aria-label={typeof children === 'string' ? children : undefined}
      aria-disabled={disabled}
    >
      {children}
    </button>
  );
};

// âœ… ä½¿ç”¨è¯­ä¹‰åŒ–HTML
const Navigation: React.FC = () => {
  return (
    <nav aria-label="ä¸»å¯¼èˆª">
      <ul>
        <li><a href="/dashboard">ä»ªè¡¨ç›˜</a></li>
        <li><a href="/signals">ä¿¡å·</a></li>
      </ul>
    </nav>
  );
};
```

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

```typescript
// âœ… ä½¿ç”¨React.memoé¿å…ä¸å¿…è¦çš„é‡æ¸²æŸ“
const SignalCard = React.memo<SignalCardProps>(({ signal }) => {
  return <div>{/* UI */}</div>;
});

// âœ… ä½¿ç”¨useMemoç¼“å­˜è®¡ç®—ç»“æœ
const Dashboard: React.FC = () => {
  const signals = useSignalData('ETHUSDT');
  
  const filteredSignals = useMemo(() => {
    return signals.filter(s => s.confidence > 0.7);
  }, [signals]);
  
  return <SignalList signals={filteredSignals} />;
};

// âœ… ä½¿ç”¨useCallbackç¼“å­˜å›è°ƒå‡½æ•°
const Dashboard: React.FC = () => {
  const [count, setCount] = useState(0);
  
  const handleClick = useCallback(() => {
    setCount(c => c + 1);
  }, []);  // ä¾èµ–ä¸ºç©ºï¼Œå‡½æ•°ä¸ä¼šé‡æ–°åˆ›å»º
  
  return <Button onClick={handleClick}>ç‚¹å‡»</Button>;
};
```

---

## ğŸ§ª æµ‹è¯•è§„èŒƒ

```typescript
// âœ… ç»„ä»¶æµ‹è¯•
import { render, screen } from '@testing-library/react';
import { SignalCard } from './SignalCard';

describe('SignalCard', () => {
  it('should render signal type', () => {
    const signal = {
      id: '1',
      type: 'LONG',
      confidence: 0.85,
      timestamp: '2025-10-13T00:00:00Z'
    };
    
    render(<SignalCard signal={signal} />);
    
    expect(screen.getByText('LONG')).toBeInTheDocument();
    expect(screen.getByText(/85.0%/)).toBeInTheDocument();
  });
  
  // ğŸ†• æµ‹è¯•é¢„çƒ­ä¿¡å·
  it('should show warmup indicator', () => {
    const signal = { /* ... */ };
    
    render(<SignalCard signal={signal} isWarmup={true} />);
    
    expect(screen.getByText(/é¢„çƒ­/)).toBeInTheDocument();
  });
});

// âœ… Hookæµ‹è¯•
import { renderHook } from '@testing-library/react-hooks';
import { useSignalData } from './useSignalData';

describe('useSignalData', () => {
  it('should fetch signals', async () => {
    const { result, waitForNextUpdate } = renderHook(() => 
      useSignalData('ETHUSDT')
    );
    
    expect(result.current.loading).toBe(true);
    
    await waitForNextUpdate();
    
    expect(result.current.loading).toBe(false);
    expect(result.current.signals).toHaveLength(10);
  });
});
```

---

**ç‰ˆæœ¬**: v4.0  
**æ›´æ–°æ—¥æœŸ**: 2025-10-13  
**æ›´æ–°å†…å®¹**:
- æ·»åŠ é¢„çƒ­ä¿¡å·UIå±•ç¤ºè§„èŒƒ
- æ·»åŠ ä¿¡å·çŠ¶æ€æ ¼å¼åŒ–å·¥å…·
- å®Œå–„ç»„ä»¶æµ‹è¯•è§„èŒƒ
**é€‚ç”¨èŒƒå›´**: frontend/**/*.{ts,tsx}
