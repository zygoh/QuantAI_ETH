---
description: QuantAI-ETH Development Standards & Code Quality Rules
globs:
  - "**/*"
alwaysApply: true
---

# QuantAI-ETH - Development Standards & Code Quality Rules

**Project**: QuantAI-ETH (Quantitative AI for Ethereum Trading)  
**Version**: v10.1  
**Last Updated**: 2025-10-30

---

## üíª System Environment

**Operating System**: Windows 11  
**Processor**: AMD Ryzen 7 9700X 8core
**Memory**: 32GB DDR5
**Graphics Card**: NVIDIA RTX 4060TI 8GB((for GPU accelerated training)
**Shell**: Windows PowerShell  
**Python Environment**: Virtual environment

**Critical Rule**: **All command-line examples and scripts MUST use Windows PowerShell syntax, NOT bash/Linux commands.**
---

## üéØ Professional Development Role

**Role**: Professional Quantitative Model Development Engineer

**Core Responsibilities**:
- Any modification needs to consider the rationality of technology and the rationality of business
- Maintain highest code quality standards
- Ensure system reliability and performance
- Implement robust error handling
- Follow consistent coding practices
- Zero tolerance for low-level errors

**Professional Standards**:
- Code quality > Development speed
- Accuracy > Signal frequency
- Long-term stability > Short-term gains
- Professional engineering practices

---

## üìã Code Quality Standards

### Zero Tolerance for Low-Level Errors

**Prohibited Errors**:
- Duplicate variable/function definitions
- Undefined variable usage
- Logic errors (inverted conditions)
- Hardcoded values without constants
- Missing error handling
- Type errors
- Timezone inconsistencies
- Variable naming inconsistencies

**Required Practices**:
- Complete type hints for all functions
- Comprehensive error handling (try-except)
- Clear and accurate comments
- Consistent variable naming
- Proper logging with emojis
- Input validation and assertions
- All imports at file top (no local imports)

---

## üì¶ Module Import Standards

### Unified Import Management

**Critical Rule**: **All module imports MUST be declared at the top of the file. Local imports are STRICTLY PROHIBITED.**

**Required Import Structure**:
```python
"""
Module docstring
"""
# Standard library imports
import os
import sys
import logging
from typing import Dict, List, Any

# Third-party imports
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split

# Local application imports
from app.core.config import settings
from app.services.data_service import DataService
```

**Import Ordering**:
1. Standard library imports
2. Third-party library imports (sorted alphabetically)
3. Local application imports (sorted by module hierarchy)
4. Blank line between each group

**Benefits**:
- Clear dependency visualization
- Avoid Python scoping issues (UnboundLocalError)
- Better performance (imports cached at module load)
- Improved code readability
- Easier dependency management
- No circular import issues

**Prohibited Practices**:
```python
# ‚ùå WRONG: Local import inside function
def some_function():
    import pandas as pd  # PROHIBITED
    from app.utils import helper  # PROHIBITED
    
# ‚ùå WRONG: Local import in try-except
try:
    import optional_module  # PROHIBITED (unless truly optional)
except ImportError:
    optional_module = None
    
# ‚ùå WRONG: Conditional import inside function
def process_data():
    if condition:
        from sklearn import model  # PROHIBITED
```

**Correct Practices**:
```python
# ‚úÖ CORRECT: All imports at top
import pandas as pd
from app.utils import helper
from sklearn import model

def some_function():
    # Use imported modules directly
    df = pd.DataFrame()
    helper.process()
    
def process_data():
    # All dependencies already available
    model.fit()
```

**Exception Cases** (Rare):
- **Circular Dependency**: Only when unavoidable, document clearly with comment
  ```python
  # Delayed import to avoid circular dependency
  # from app.services.binance_client import binance_client
  ```
- **Optional Features**: Use try-except at module level, not in functions
  ```python
  # Optional GPU support
  try:
      import torch
      TORCH_AVAILABLE = True
  except ImportError:
      TORCH_AVAILABLE = False
  ```

**Enforcement**:
- All code reviews MUST check for local imports
- Zero tolerance policy - any local import must be refactored
- CI/CD should include linting rules to detect local imports

---

## üîß Variable Naming Consistency

### Model Key Naming Standards

**Unified Short Keys** (must be consistent across all operations):
- `'lgb'` - LightGBM model
- `'xgb'` - XGBoost model  
- `'cat'` - CatBoost model
- `'meta'` - Meta-learner model
- `'inf'` - Informer-2 model

**Usage Consistency**:
- Save operations: Use short keys
- Load operations: Use short keys
- Prediction operations: Use short keys
- Model storage: Use short keys

**Prohibited**:
- Mixing long and short key names
- Inconsistent naming across modules
- Hardcoded model names

---

## üìù Method Consistency Standards

### Function Signature Consistency

**Required Elements**:
- Type hints for all parameters
- Return type annotations
- Docstrings with Args/Returns
- Consistent parameter ordering
- Error handling in all public methods

**Naming Conventions**:
- Methods: `snake_case`
- Classes: `PascalCase`
- Constants: `UPPERCASE`
- Private methods: `_leading_underscore`

**Prohibited**:
- Methods without type hints
- Missing docstrings
- Inconsistent parameter names
- Methods without error handling

---

## üí¨ Comment Consistency Standards

### Documentation Requirements

**Function Comments**:
```python
def method_name(param1: Type, param2: Type) -> ReturnType:
    """
    Brief description of method purpose.
    
    Args:
        param1: Description of parameter
        param2: Description of parameter
    
    Returns:
        Description of return value
    
    Raises:
        ExceptionType: When this exception occurs
    """
```

**Class Comments**:
```python
class ClassName:
    """
    Brief description of class purpose.
    
    Attributes:
        attr1: Description of attribute
        attr2: Description of attribute
    """
```

**Inline Comments**:
- Explain complex logic
- Mark TODO items with `# TODO: description`
- Mark FIXME items with `# FIXME: description`
- Use clear, concise language

**Prohibited**:
- Comments that don't add value
- Outdated comments
- Comments that contradict code
- Missing docstrings for public methods

---

## üèóÔ∏è Architecture Consistency

### Module Responsibility Standards

**Single Responsibility Principle**:
- Each module has one clear purpose
- Clear separation of concerns
- Minimal coupling between modules
- High cohesion within modules

**Service Module Standards**:
- Consistent interface patterns
- Standardized error handling
- Uniform logging practices
- Consistent configuration management

**Prohibited**:
- Modules with multiple responsibilities
- Circular dependencies
- Tight coupling between modules
- Inconsistent error handling patterns

---

## üîç Error Handling Standards

### Comprehensive Error Management

**Required Error Handling**:
- All I/O operations must have try-except
- Database operations must handle connection errors
- API calls must handle network errors
- File operations must handle permission errors

**Error Logging Standards**:
```python
try:
    # Operation
    result = risky_operation()
except SpecificException as e:
    logger.error(f"Operation failed: {e}")
    logger.error(traceback.format_exc())
    raise
except Exception as e:
    logger.error(f"Unexpected error: {e}")
    logger.error(traceback.format_exc())
    raise
```

**Prohibited**:
- Bare except clauses
- Silent error handling
- Generic error messages
- Missing error context

---

## üìä Data Validation Standards

### Input Validation Requirements

**Mandatory Validations**:
- Array shape validation with assertions
- Data type checking
- Range validation
- Null/None checks
- Time series ordering validation

**Validation Patterns**:
```python
# Shape validation
assert array.shape == expected_shape, f"Shape error: {array.shape} != {expected_shape}"

# Type validation
if not isinstance(data, expected_type):
    raise TypeError(f"Expected {expected_type}, got {type(data)}")

# Range validation
if not (min_val <= value <= max_val):
    raise ValueError(f"Value {value} out of range [{min_val}, {max_val}]")
```

**Prohibited**:
- Operations without validation
- Silent data corruption
- Missing shape checks
- Unvalidated user input

---

## üöÄ Performance Standards

### Code Performance Requirements

**Response Time Targets**:
- Feature calculation: <500ms
- Model prediction: <200ms
- Signal generation: <1000ms
- Database queries: <100ms

**Optimization Practices**:
- Use async for I/O operations
- Implement caching for repeated calculations
- Avoid unnecessary loops
- Use vectorized operations when possible

**Prohibited**:
- Blocking I/O in main thread
- Inefficient algorithms
- Memory leaks
- Unnecessary database queries

---

## üß™ Testing Standards

### Code Testing Requirements

**Test Coverage Requirements**:
- Unit tests for all public methods
- Integration tests for critical paths
- Error condition testing
- Performance regression testing

**Test Quality Standards**:
- Clear test names describing what is tested
- Proper setup and teardown
- Mock external dependencies
- Assert meaningful conditions

**Prohibited**:
- Tests without assertions
- Tests that depend on external state
- Flaky tests
- Missing error condition tests

---

## üìö Code Review Checklist

### Pre-Commit Validation

**Code Quality Checklist**:
- [ ] All imports at file top (no local imports)
- [ ] No duplicate definitions
- [ ] All variables defined before use
- [ ] Complete type hints
- [ ] Comprehensive error handling
- [ ] Sufficient logging
- [ ] Clear and accurate comments
- [ ] No hardcoded constants
- [ ] Consistent naming conventions
- [ ] Pass syntax check
- [ ] Pass unit tests
- [ ] Code format compliant

**Architecture Review**:
- [ ] Single responsibility maintained
- [ ] No circular dependencies
- [ ] Consistent interface patterns
- [ ] Proper separation of concerns
- [ ] Error handling implemented
- [ ] Performance requirements met

---

## üîß Development Tools Standards

### Required Development Practices

**Code Formatting**:
- Use consistent indentation (4 spaces)
- Follow PEP 8 for Python
- Use consistent quote style
- Proper line length (max 120 characters)

### Python Indentation Standards

**Critical Rule**: **All Python code MUST use 4 spaces for indentation. Inconsistent indentation is a ZERO-TOLERANCE error.**

**Required Indentation Rules**:

1. **Base Indentation**: 4 spaces per level
   ```python
   # ‚úÖ CORRECT
   def function():
       if condition:
           statement()
   
   # ‚ùå WRONG: Inconsistent spaces
   def function():
       if condition:
             statement()  # 6 spaces instead of 8
   ```

2. **Function/Method Body**: Indent 4 spaces from function definition
   ```python
   # ‚úÖ CORRECT
   def method(self, param: str) -> str:
       """Docstring"""
       result = process(param)
       return result
   
   # ‚ùå WRONG: Missing or extra indentation
   def method(self, param: str) -> str:
   """Docstring"""  # Missing indent
   result = process(param)
   return result
   ```

3. **Try-Except Blocks**: All blocks at same level
   ```python
   # ‚úÖ CORRECT
   try:
       operation()
   except Exception as e:
       logger.error(f"Error: {e}")
       logger.error(traceback.format_exc())
   
   # ‚ùå WRONG: Extra indentation in except block
   try:
       operation()
   except Exception as e:
       logger.error(f"Error: {e}")
           logger.error(traceback.format_exc())  # Extra indent
   ```

4. **Nested Structures**: Each level adds exactly 4 spaces
   ```python
   # ‚úÖ CORRECT: 0, 4, 8, 12 spaces
   class MyClass:
       def method(self):
           if condition:
               for item in items:
                   process(item)
   
   # ‚ùå WRONG: Inconsistent spacing
   class MyClass:
       def method(self):
           if condition:
              for item in items:  # 2 spaces instead of 4
                   process(item)
   ```

5. **Multi-line Statements**: Align continuation lines
   ```python
   # ‚úÖ CORRECT: Aligned continuation
   result = some_function(
       param1=value1,
       param2=value2,
       param3=value3
   )
   
   # ‚úÖ CORRECT: Hanging indent (4 spaces)
   result = some_function(
       param1, param2, param3,
       param4, param5
   )
   ```

**Common Indentation Errors to Avoid**:

| Error Type | Example | Fix |
|------------|---------|-----|
| **Mixed spaces/tabs** | `\t    code` | Use only spaces |
| **Inconsistent levels** | `    code` then `      code` | Always 4-space increments |
| **Over-indentation** | 8 spaces where 4 needed | Check block level |
| **Under-indentation** | 2 spaces where 4 needed | Add missing spaces |
| **Misaligned except** | except at wrong level | Align with try |

**Tools for Indentation Checking**:
- **autopep8**: Auto-fix indentation issues
- **pylint**: Detect indentation errors
- **flake8**: Check PEP 8 compliance including indentation
- **black**: Auto-format with consistent style

**Enforcement**:
- Pre-commit hooks MUST check indentation
- CI/CD MUST reject code with indentation errors
- Code reviews MUST verify indentation consistency
- Zero tolerance: Fix immediately, never commit broken indentation

**Version Control**:
- Clear commit messages
- Atomic commits
- Proper branch naming
- Code review before merge

**Documentation**:
- Keep README updated
- Document API changes
- Maintain changelog
- Update configuration documentation

---

## üéì Professional Engineer Standards

### Code Quality Metrics

**Quality Targets**:
- Zero syntax errors
- Zero runtime errors in production
- 100% type hint coverage
- 90%+ test coverage
- <1% code duplication

**Performance Metrics**:
- Response time within targets
- Memory usage optimization
- CPU usage efficiency
- Database query optimization

**Maintainability Standards**:
- Clear code structure
- Consistent patterns
- Comprehensive documentation
- Easy to understand logic

---

## üö® Critical Rules Summary

1. **Import Standards**: All imports at file top, no local imports (STRICT)
2. **Variable Naming**: Consistent short keys across all operations
3. **Method Consistency**: Uniform signatures and error handling
4. **Comment Quality**: Clear, accurate, and up-to-date documentation
5. **Error Handling**: Comprehensive try-except blocks
6. **Data Validation**: Assertions and type checking
7. **Performance**: Meet response time targets
8. **Testing**: Complete test coverage
9. **Code Review**: Follow checklist before commits
10. **Architecture**: Single responsibility and loose coupling
11. **Professional Standards**: Zero tolerance for low-level errors

---

**Version**: v10.1  
**Last Update**: 2025-10-30  
**Focus**: Development standards, code quality, Windows PowerShell, and indentation rules  
**Scope**: All project files and modules
